# 算术运算符

```java
public class ArithmeticOperatorsDemo {  
    public static void main(String[] args) {  
        // +  
        System.out.println(3+2);//5  
        //-        
        System.out.println(9-2);//7  
        //*        
        System.out.println(2*3);//6  
        //÷        
        System.out.println(6/3);//2  
        //取模/取余  
        System.out.println(6%5);//1  
        System.out.println(6%3);//0  
    }  
}
```
>字符串可以进行加法操作，但在进行加法操作时，需要从前往后进行运算，且没遇到字符串时数值相加，遇到字符串后开始字符拼接，如：
>
```java
System. out. println(3.7 + "abc"); //"3.7abc"
System. out . println("abc" + true); //"abctrue'
System . out. println('中' + "abc" + true); //"中abctrue"
System.out. println(1 + 2 + "abc"+ 2 + 1) ;//"3abc21"
```

# 自增自减运算符
++和--无论是放在变量的前边还是后边，**单独写一行时**结果是一样的。
![](../../附件/Pasted%20image%2020230217114645.png)
```java
int x = 10;  
//后++:先用后加
//先把x变量中的值拿出来用，赋值给y，然后再进行自增。
//赋值给y的值是自增前的。
int y = x++;  
//先++:先加后用
//先把x进行自增，然后把自增后的结果赋值给左边的变量
//先把x自增，变成12，然后再把自增之后的12赋值给z
int z = ++x;  
System.out.println("x:" + x);  //12
System.out.println("y:" + y);  //10
System.out.println("z:" + z);  //12
```

# 隐式转换与强制转换
## 隐式转换
1、数据范围大小 byte < short < int < long < float < double  

2、数据类型不一样，不能进行计算，需要转成一样的才可以进行计算。  

3、取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算  

4、byte short char三种类型的数据在运算的时候，都会直接先提升为int,然后再进行运算
## 强制转换
把取值范围大的变量修改成取值范围小的时  
格式： 目标数据类型  变量命 = (目标数据类型) 被强制转换的变量命  
例如：  

```java
double a = 12.3  
int b = (int) a;
```

# 赋值运算符

| 符号 |    作用    |           说明           |
|:----:|:----------:|:------------------------:|
|  =   |    赋值    | int a=10,将10赋值给变量a |
|  +=  |  加后赋值  |    a+=b,将a+b的值给a     |
|  -=  |  减后赋值  |    a-=b，将a-b的值给a    |
| `*=` |  乘后赋值  |    a*=b,将axb的值给a     |
|  /=  |  除后赋值  |    a/=b,将a+b的商给a     |
|  %=  | 取余后赋值 |   a%=b，将a+b的余数给a   |
>注：`+= -= *= /= %=` 底层都有一个强制转换

# 关系运算符

| 符号 |                          说明                           |
|:----:|:-------------------------------------------------------:|
|  ==  | `a==b，判断a和b的值是否相等，成立为true,不成立为false ` |
|  !=  | `a!=b,判断a和b的值是否不相等，成立为true,不成立为false` |
|  >   |     `a>b，判断a是否大于b,成立为true,不成立为false`      |
|  >=  |   `a>=b,判断a是否大于等于b,成立为true,不成立为false`    |
|  <   |     `a<b，判断a是否小于b,成立为true,不成立为false`      |
|  <=  |   `a<=b,判断a是否小于等于b,成立为true,不成立为false`    |
>注意事项：关系运算符的结果都是boolean类型,要么是true,要么是false。

# 逻辑运算符
|  符号  |    作用    |               说明               |                |
|:------:|:----------:|:--------------------------------:|:--------------:|
|   &    | 逻辑与(且) |  **并且**,两边都为真,结果才是真  |  两边都要满足  |
| &#124; |   逻辑或   | **或者**，两边都为假，结果才是假 | 两边有一个满足 |
|   ^    |  逻辑异或  |      相同为false,不同为true      |                |
|   !    |   逻辑非   |               取反               |                |

## 短路逻辑运算符
|     符号     |  作用  |               说明               |
|:------------:|:------:|:--------------------------------:|
|     ＆＆     | 短路与 |   结果和&相同，但是有短路效果    |
| &#124;&#124; | 短路或 | 结果和&#124;相同，但是有短路效果 |
>注意事项:  
>&和|， 无论左边true false,右边都要执行。   
>&&和||，如果左边能确定整个表达式的结果，**右边不执行**。  
>&&:左边为false，右边不管是真是假，整个表达式的结果-定是false。  
>||:左边为true,右边不管是真是假，整个表达式的结果一定是true。  
>这两种情况下，右边不执行，提高了效率。   
>最常用的逻辑运算符: &&， ||， |  

# 三元运算符
```java
public class test {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        
        // 数据类型 变量名称 = 条件判断 ? 表达式A : 表达式B;
        // 判断a > b是否成立，如果成立将a的值赋值给max；如果不成立将b的值赋值给max。二者选其一
        int max = a > b ? a : b; // 最大值的变量
        System.out.println("最大值：" + max); // 20
        
        // int result = 3 > 4 ? 2.5 : 10; // 错误写法！
        
        System.out.println(a > b ? a : b); // 正确写法！
        
        // a > b ? a : b; // 错误写法！
    }
}
```
注：三元运算符的结果不能单独成行，必须要使用或者赋值

# 其他运算符
| 运算符 |    含义    |       运算规则       |
|:------:|:----------:|:--------------------:|
|   &    |   逻辑与   |   0为false 1为true   |
| &#124; |   逻辑或   |   0为false 1为true   |
|   <<   |    左移    |  向左移动，低位补0   |
|   >>   |    右移    |  向右移动，高位补0   |
|  >>>   | 无符号右移 | 向右移动，高位补0或1 |
>注：左移一次，数值乘2  
>注：右移一次，数值除2

# 源码、反码、补码
## 源码
十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。

### 源码的弊端
利用原码进行计算的时候，如果是正数完全没有问题。

但是如果是负数计算，结果就出错，实际运算的方向，跟正确的运算方向是相反的。
## 反码
为了解决原码不能计算负数的问题而出现的。

### 反码计算规则
正数的反码不变，负数的反码在原码的基础上，符号位不变。数值取反，0变1，1变0。

### 反码的弊端
负数运算的时候，如果结果不跨0，是没有任何问题的，但是如果结果跨0,跟实际结果会有1的偏差。

## 补码
为了解决负数计算时跨0的问题而出现的。

### 补码的计算规则
正数的补码不变，负数的补码在反码的基础上+1。

另外补码还能多记录一个特殊的值-128，该数据在1个字节下，没有原码和反码。

### 补码的注意点
计算机中的存储和计算都是以补码的形式进行的。

